<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="kube-controller-manager,replicaset controller,">





  <link rel="alternate" href="/atom.xml" title="田飞雨" type="application/atom+xml">






<meta name="description" content="在前面的文章中已经介绍了 deployment controller 的设计与实现，deployment 控制的是 replicaset，而 replicaset 控制 pod 的创建与删除，deployment 通过控制 replicaset 实现了滚动更新、回滚等操作。而 replicaset 会直接控制 pod 的创建与删除，本文会继续从源码层面分析 replicaset 的设计与实现。 在">
<meta name="keywords" content="kube-controller-manager,replicaset controller">
<meta property="og:type" content="article">
<meta property="og:title" content="replicaset controller 源码分析">
<meta property="og:url" content="https://blog.tianfeiyu.com/2019/12/08/replicaset_controller/index.html">
<meta property="og:site_name" content="田飞雨">
<meta property="og:description" content="在前面的文章中已经介绍了 deployment controller 的设计与实现，deployment 控制的是 replicaset，而 replicaset 控制 pod 的创建与删除，deployment 通过控制 replicaset 实现了滚动更新、回滚等操作。而 replicaset 会直接控制 pod 的创建与删除，本文会继续从源码层面分析 replicaset 的设计与实现。 在">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-12-09T01:26:42.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="replicaset controller 源码分析">
<meta name="twitter:description" content="在前面的文章中已经介绍了 deployment controller 的设计与实现，deployment 控制的是 replicaset，而 replicaset 控制 pod 的创建与删除，deployment 通过控制 replicaset 实现了滚动更新、回滚等操作。而 replicaset 会直接控制 pod 的创建与删除，本文会继续从源码层面分析 replicaset 的设计与实现。 在">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>




  <link rel="canonical" href="https://blog.tianfeiyu.com/2019/12/08/replicaset_controller/">






  <title>replicaset controller 源码分析 | 田飞雨</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">田飞雨</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">专注 k8s 云原生实践</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-ebook">
          <a href="/source-code-reading-notes/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br>
            
            电子书
          </a>
        </li>
      
        
        <li class="menu-item menu-item-rss">
          <a href="/atom.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-rss"></i> <br>
            
            rss
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-replicaset controller" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.tianfeiyu.com/2019/12/08/replicaset_controller/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tianfeiyu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="田飞雨">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">replicaset controller 源码分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-08T17:00:30+08:00">
                2019-12-08
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/08/replicaset_controller/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/08/replicaset_controller/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>在前面的文章中已经介绍了 deployment controller 的设计与实现，deployment 控制的是 replicaset，而 replicaset 控制 pod 的创建与删除，deployment 通过控制 replicaset 实现了滚动更新、回滚等操作。而 replicaset 会直接控制 pod 的创建与删除，本文会继续从源码层面分析 replicaset 的设计与实现。</p>
<p>在分析源码前先考虑一下 replicaset 的使用场景，在平时的操作中其实我们并不会直接操作 replicaset，replicaset 也仅有几个简单的操作，创建、删除、更新等，但其地位是非常重要的，replicaset 的主要功能就是通过 add/del pod 来达到期望的状态。</p>
<h3 id="ReplicaSetController-源码分析"><a href="#ReplicaSetController-源码分析" class="headerlink" title="ReplicaSetController 源码分析"></a>ReplicaSetController 源码分析</h3><blockquote>
<p>kubernetes 版本: v1.16</p>
</blockquote>
<h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><p>首先来看 replicaSetController 对象初始化以及启动的代码，在 startReplicaSetController 中有两个比较重要的变量：</p>
<ul>
<li>BurstReplicas：用来控制在一个 syncLoop 过程中 rs 最多能创建的 pod 数量，设置上限值是为了避免单个 rs 影响整个系统，默认值为 500；</li>
<li>ConcurrentRSSyncs：指的是需要启动多少个 goroutine 处理 informer 队列中的对象，默认值为 5；</li>
</ul>
<p><code>k8s.io/kubernetes/cmd/kube-controller-manager/app/apps.go:69</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func startReplicaSetController(ctx ControllerContext) (http.Handler, bool, error) &#123;</span><br><span class="line">    if !ctx.AvailableResources[schema.GroupVersionResource&#123;Group: &quot;apps&quot;, Version: &quot;v1&quot;, Resource: &quot;replicasets&quot;&#125;] &#123;</span><br><span class="line">        return nil, false, nil</span><br><span class="line">    &#125;</span><br><span class="line">    go replicaset.NewReplicaSetController(</span><br><span class="line">        ctx.InformerFactory.Apps().V1().ReplicaSets(),</span><br><span class="line">        ctx.InformerFactory.Core().V1().Pods(),</span><br><span class="line">        ctx.ClientBuilder.ClientOrDie(&quot;replicaset-controller&quot;),</span><br><span class="line">        replicaset.BurstReplicas,</span><br><span class="line">    ).Run(int(ctx.ComponentConfig.ReplicaSetController.ConcurrentRSSyncs), ctx.Stop)</span><br><span class="line">    return nil, true, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是 replicaSetController 初始化的具体步骤，可以看到其会监听 pod 以及 rs 两个对象的事件。</p>
<p><code>k8s.io/kubernetes/pkg/controller/replicaset/replica_set.go:109</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">func NewReplicaSetController(......) *ReplicaSetController &#123;</span><br><span class="line">    ......</span><br><span class="line">    // 1、此处调用 NewBaseController</span><br><span class="line">    return NewBaseController(rsInformer, podInformer, kubeClient, burstReplicas,</span><br><span class="line">        apps.SchemeGroupVersion.WithKind(&quot;ReplicaSet&quot;),</span><br><span class="line">        &quot;replicaset_controller&quot;,</span><br><span class="line">        &quot;replicaset&quot;,</span><br><span class="line">        controller.RealPodControl&#123;</span><br><span class="line">            KubeClient: kubeClient,</span><br><span class="line">            Recorder:   eventBroadcaster.NewRecorder(scheme.Scheme, v1.EventSource&#123;Component: &quot;replicaset-controller&quot;&#125;),</span><br><span class="line">        &#125;,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewBaseController(......) *ReplicaSetController &#123;</span><br><span class="line">    ......</span><br><span class="line">    // 2、ReplicaSetController 初始化</span><br><span class="line">    rsc := &amp;ReplicaSetController&#123;</span><br><span class="line">        GroupVersionKind: gvk,</span><br><span class="line">        kubeClient:       kubeClient,</span><br><span class="line">        podControl:       podControl,</span><br><span class="line">        burstReplicas:    burstReplicas,</span><br><span class="line">        // 3、expectations 的初始化</span><br><span class="line">        expectations:     controller.NewUIDTrackingControllerExpectations(controller.NewControllerExpectations()),</span><br><span class="line">        queue:            workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), queueName),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 4、rsInformer 中注册的 EventHandler</span><br><span class="line">    rsInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">        AddFunc:    rsc.enqueueReplicaSet,</span><br><span class="line">        UpdateFunc: rsc.updateRS,</span><br><span class="line">        DeleteFunc: rsc.enqueueReplicaSet,</span><br><span class="line">    &#125;)</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    // 5、podInformer 中注册的 EventHandler</span><br><span class="line">    podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">        AddFunc: rsc.addPod,</span><br><span class="line">        UpdateFunc: rsc.updatePod,</span><br><span class="line">        DeleteFunc: rsc.deletePod,</span><br><span class="line">    &#125;)</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    return rsc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>replicaSetController 初始化完成后会调用 <code>Run</code> 方法启动 5 个 goroutine 处理 informer 队列中的事件并进行 sync 操作，kube-controller-manager 中每个 controller 的启动操作都是如下所示流程。</p>
<p><code>k8s.io/kubernetes/pkg/controller/replicaset/replica_set.go:177</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">func (rsc *ReplicaSetController) Run(workers int, stopCh &lt;-chan struct&#123;&#125;) &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    // 1、等待 informer 同步缓存</span><br><span class="line">    if !cache.WaitForNamedCacheSync(rsc.Kind, stopCh, rsc.podListerSynced, rsc.rsListerSynced) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2、启动 5 个 goroutine 执行 worker 方法</span><br><span class="line">    for i := 0; i &lt; workers; i++ &#123;</span><br><span class="line">        go wait.Until(rsc.worker, time.Second, stopCh)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &lt;-stopCh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3、worker 方法中调用 rocessNextWorkItem</span><br><span class="line">func (rsc *ReplicaSetController) worker() &#123;</span><br><span class="line">    for rsc.processNextWorkItem() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (rsc *ReplicaSetController) processNextWorkItem() bool &#123;</span><br><span class="line">    // 4、从队列中取出对象</span><br><span class="line">    key, quit := rsc.queue.Get()</span><br><span class="line">    if quit &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    defer rsc.queue.Done(key)</span><br><span class="line"></span><br><span class="line">    // 5、执行 sync 操作</span><br><span class="line">    err := rsc.syncHandler(key.(string))</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="EventHandler"><a href="#EventHandler" class="headerlink" title="EventHandler"></a>EventHandler</h4><p>初始化 replicaSetController 时，其中有一个 <code>expectations</code> 字段，这是 rs 中一个比较特殊的机制，为了说清楚 expectations，先来看一下 controller 中所注册的 eventHandler，replicaSetController 会 watch pod 和 replicaSet 两个对象，eventHandler 中注册了对这两种对象的 add、update、delete 三个操作。</p>
<h5 id="addPod"><a href="#addPod" class="headerlink" title="addPod"></a>addPod</h5><ul>
<li>1、判断 pod 是否处于删除状态；</li>
<li>2、获取该 pod 关联的 rs 以及 rsKey，入队 rs 并更新 rsKey 的 expectations；</li>
<li>3、若 pod 对象没体现出关联的 rs 则为孤儿 pod，遍历 rsList 查找匹配的 rs，若该 rs.Namespace == pod.Namespace 并且 rs.Spec.Selector 匹配 pod.Labels，则说明该 pod 应该与此 rs 关联，将匹配的 rs 入队；</li>
</ul>
<p><code>k8s.io/kubernetes/pkg/controller/replicaset/replica_set.go:255</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">func (rsc *ReplicaSetController) addPod(obj interface&#123;&#125;) &#123;</span><br><span class="line">    pod := obj.(*v1.Pod)</span><br><span class="line"></span><br><span class="line">    if pod.DeletionTimestamp != nil &#123;</span><br><span class="line">        rsc.deletePod(pod)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1、获取 pod 所关联的 rs</span><br><span class="line">    if controllerRef := metav1.GetControllerOf(pod); controllerRef != nil &#123;</span><br><span class="line">        rs := rsc.resolveControllerRef(pod.Namespace, controllerRef)</span><br><span class="line">        if rs == nil &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        rsKey, err := controller.KeyFunc(rs)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        // 2、更新 expectations，rsKey 的 add - 1</span><br><span class="line">        rsc.expectations.CreationObserved(rsKey)</span><br><span class="line">        rsc.enqueueReplicaSet(rs)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    rss := rsc.getPodReplicaSets(pod)</span><br><span class="line">    if len(rss) == 0 &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for _, rs := range rss &#123;</span><br><span class="line">        rsc.enqueueReplicaSet(rs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="updatePod"><a href="#updatePod" class="headerlink" title="updatePod"></a>updatePod</h5><ul>
<li>1、如果 pod label 改变或者处于删除状态，则直接删除；</li>
<li>2、如果 pod 的 OwnerReference 发生改变，此时 oldRS 需要创建 pod，将 oldRS 入队；</li>
<li>3、获取 pod 关联的 rs，入队 rs，若 pod 当前处于 ready 并非 available 状态，则会再次将该 rs 加入到延迟队列中，因为 pod 从 ready 到 available 状态需要触发一次 status 的更新；</li>
<li>4、否则为孤儿 pod，遍历 rsList 查找匹配的 rs，若找到则将 rs 入队；</li>
</ul>
<p><code>k8s.io/kubernetes/pkg/controller/replicaset/replica_set.go:298</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">func (rsc *ReplicaSetController) updatePod(old, cur interface&#123;&#125;) &#123;</span><br><span class="line">    curPod := cur.(*v1.Pod)</span><br><span class="line">    oldPod := old.(*v1.Pod)</span><br><span class="line">    if curPod.ResourceVersion == oldPod.ResourceVersion &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1、如果 pod label 改变或者处于删除状态，则直接删除</span><br><span class="line">    labelChanged := !reflect.DeepEqual(curPod.Labels, oldPod.Labels)</span><br><span class="line">    if curPod.DeletionTimestamp != nil &#123;</span><br><span class="line">        rsc.deletePod(curPod)</span><br><span class="line">        if labelChanged &#123;</span><br><span class="line">            rsc.deletePod(oldPod)</span><br><span class="line">        &#125;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2、如果 pod 的 OwnerReference 发生改变，将 oldRS 入队</span><br><span class="line">    curControllerRef := metav1.GetControllerOf(curPod)</span><br><span class="line">    oldControllerRef := metav1.GetControllerOf(oldPod)</span><br><span class="line">    controllerRefChanged := !reflect.DeepEqual(curControllerRef, oldControllerRef)</span><br><span class="line">    if controllerRefChanged &amp;&amp; oldControllerRef != nil &#123;</span><br><span class="line">        if rs := rsc.resolveControllerRef(oldPod.Namespace, oldControllerRef); rs != nil &#123;</span><br><span class="line">            rsc.enqueueReplicaSet(rs)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3、获取 pod 关联的 rs，入队 rs</span><br><span class="line">    if curControllerRef != nil &#123;</span><br><span class="line">        rs := rsc.resolveControllerRef(curPod.Namespace, curControllerRef)</span><br><span class="line">        if rs == nil &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rsc.enqueueReplicaSet(rs)</span><br><span class="line">        if !podutil.IsPodReady(oldPod) &amp;&amp; podutil.IsPodReady(curPod) &amp;&amp; rs.Spec.MinReadySeconds &gt; 0 &#123;</span><br><span class="line">            rsc.enqueueReplicaSetAfter(rs, (time.Duration(rs.Spec.MinReadySeconds)*time.Second)+time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 4、查找匹配的 rs</span><br><span class="line">    if labelChanged || controllerRefChanged &#123;</span><br><span class="line">        rss := rsc.getPodReplicaSets(curPod)</span><br><span class="line">        if len(rss) == 0 &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        for _, rs := range rss &#123;</span><br><span class="line">            rsc.enqueueReplicaSet(rs)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="deletePod"><a href="#deletePod" class="headerlink" title="deletePod"></a>deletePod</h5><ul>
<li>1、确认该对象是否为 pod；</li>
<li>2、判断是否为孤儿 pod；</li>
<li>3、获取其对应的 rs 以及 rsKey；</li>
<li>4、更新 expectations 中 rsKey 的 del 值；</li>
<li>5、将 rs 入队；</li>
</ul>
<p><code>k8s.io/kubernetes/pkg/controller/replicaset/replica_set.go:372</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func (rsc *ReplicaSetController) deletePod(obj interface&#123;&#125;) &#123;</span><br><span class="line">    pod, ok := obj.(*v1.Pod)</span><br><span class="line"></span><br><span class="line">    if !ok &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    controllerRef := metav1.GetControllerOf(pod)</span><br><span class="line">    if controllerRef == nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    rs := rsc.resolveControllerRef(pod.Namespace, controllerRef)</span><br><span class="line">    if rs == nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    rsKey, err := controller.KeyFunc(rs)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    // 更新 expectations，该 rsKey 的 del - 1</span><br><span class="line">    rsc.expectations.DeletionObserved(rsKey, controller.PodKey(pod))</span><br><span class="line">    rsc.enqueueReplicaSet(rs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="AddRS-和-DeleteRS"><a href="#AddRS-和-DeleteRS" class="headerlink" title="AddRS 和 DeleteRS"></a>AddRS 和 DeleteRS</h5><p>以上两个操作仅仅是将对应的 rs 入队。</p>
<p>#####UpdateRS</p>
<p>其实 updateRS 也仅仅是将对应的 rs 进行入队，不过多了一个打印日志的操作，如下所示：</p>
<p><code>k8s.io/kubernetes/pkg/controller/replicaset/replica_set.go:232</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func (rsc *ReplicaSetController) updateRS(old, cur interface&#123;&#125;) &#123;</span><br><span class="line">    oldRS := old.(*apps.ReplicaSet)</span><br><span class="line">    curRS := cur.(*apps.ReplicaSet)</span><br><span class="line"></span><br><span class="line">    if *(oldRS.Spec.Replicas) != *(curRS.Spec.Replicas) &#123;</span><br><span class="line">        klog.V(4).Infof(&quot;%v %v updated. Desired pod count change: %d-&gt;%d&quot;, rsc.Kind, curRS.Name, *(oldRS.Spec.Replicas), *(curRS.Spec.Replicas))</span><br><span class="line">    &#125;</span><br><span class="line">    rsc.enqueueReplicaSet(cur)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于 expectations 机制会在下文进行分析。</p>
<h4 id="syncReplicaSet"><a href="#syncReplicaSet" class="headerlink" title="syncReplicaSet"></a>syncReplicaSet</h4><p>syncReplicaSet 是 controller 的核心方法，它会驱动 controller 所控制的对象达到期望状态，主要逻辑如下所示：</p>
<ul>
<li>1、根据 ns/name 获取 rs 对象；</li>
<li>2、调用 expectations.SatisfiedExpectations 判断是否需要执行真正的 sync 操作；</li>
<li>3、获取所有 pod list；</li>
<li>4、根据 pod label 进行过滤获取与该 rs 关联的 pod 列表，对于其中的孤儿 pod 若与该 rs label 匹配则进行关联，若已关联的 pod 与 rs label 不匹配则解除关联关系；</li>
<li>5、调用 manageReplicas 进行同步 pod 操作，add/del pod；</li>
<li>6、计算 rs 当前的 status 并进行更新；</li>
<li>7、若 rs 设置了 MinReadySeconds 字段则将该 rs 加入到延迟队列中；</li>
</ul>
<p><code>k8s.io/kubernetes/pkg/controller/replicaset/replica_set.go:562</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">func (rsc *ReplicaSetController) syncReplicaSet(key string) error &#123;</span><br><span class="line">		......</span><br><span class="line"></span><br><span class="line">    namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1、根据 ns/name 从 informer cache 中获取 rs 对象，</span><br><span class="line">    // 若 rs 已经被删除则直接删除 expectations 中的对象</span><br><span class="line">    rs, err := rsc.rsLister.ReplicaSets(namespace).Get(name)</span><br><span class="line">    if errors.IsNotFound(err) &#123;</span><br><span class="line">        rsc.expectations.DeleteExpectations(key)</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    // 2、判断该 rs 是否需要执行 sync 操作</span><br><span class="line">    rsNeedsSync := rsc.expectations.SatisfiedExpectations(key)</span><br><span class="line">    selector, err := metav1.LabelSelectorAsSelector(rs.Spec.Selector)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3、获取所有 pod list</span><br><span class="line">    allPods, err := rsc.podLister.Pods(rs.Namespace).List(labels.Everything())</span><br><span class="line">		......</span><br><span class="line"></span><br><span class="line">    // 4、过滤掉异常 pod，处于删除状态或者 failed 状态的 pod 都为非 active 状态</span><br><span class="line">    filteredPods := controller.FilterActivePods(allPods)</span><br><span class="line"></span><br><span class="line">    // 5、检查所有 pod，根据 pod 并进行 adopt 与 release 操作，最后获取与该 rs 关联的 pod list</span><br><span class="line">    filteredPods, err = rsc.claimPods(rs, selector, filteredPods)</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    // 6、若需要 sync 则执行 manageReplicas 创建/删除 pod</span><br><span class="line">    var manageReplicasErr error</span><br><span class="line">    if rsNeedsSync &amp;&amp; rs.DeletionTimestamp == nil &#123;</span><br><span class="line">        manageReplicasErr = rsc.manageReplicas(filteredPods, rs)</span><br><span class="line">    &#125;</span><br><span class="line">    rs = rs.DeepCopy()</span><br><span class="line">    // 7、计算 rs 当前的 status</span><br><span class="line">    newStatus := calculateStatus(rs, filteredPods, manageReplicasErr)</span><br><span class="line"></span><br><span class="line">    // 8、更新 rs status</span><br><span class="line">    updatedRS, err := updateReplicaSetStatus(rsc.kubeClient.AppsV1().ReplicaSets(rs.Namespace), rs, newStatus)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 9、判断是否需要将 rs 加入到延迟队列中</span><br><span class="line">    if manageReplicasErr == nil &amp;&amp; updatedRS.Spec.MinReadySeconds &gt; 0 &amp;&amp;</span><br><span class="line">        updatedRS.Status.ReadyReplicas == *(updatedRS.Spec.Replicas) &amp;&amp;</span><br><span class="line">        updatedRS.Status.AvailableReplicas != *(updatedRS.Spec.Replicas) &#123;</span><br><span class="line">        rsc.enqueueReplicaSetAfter(updatedRS, time.Duration(updatedRS.Spec.MinReadySeconds)*time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">    return manageReplicasErr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>syncReplicaSet</code> 方法中有几个重要的操作分别为：<code>rsc.expectations.SatisfiedExpectations</code>、<code>rsc.manageReplicas</code>、<code>calculateStatus</code>，下面一一进行分析。</p>
<h5 id="SatisfiedExpectations"><a href="#SatisfiedExpectations" class="headerlink" title="SatisfiedExpectations"></a>SatisfiedExpectations</h5><p>该方法主要判断 rs 是否需要执行真正的同步操作，若需要 add/del pod 或者 expectations 已过期则需要进行同步操作。</p>
<p><code>k8s.io/kubernetes/pkg/controller/controller_utils.go:181</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func (r *ControllerExpectations) SatisfiedExpectations(controllerKey string) bool &#123;</span><br><span class="line">    // 1、若该 key 存在时，判断是否满足条件或者是否超过同步周期</span><br><span class="line">    if exp, exists, err := r.GetExpectations(controllerKey); exists &#123;</span><br><span class="line">        if exp.Fulfilled() &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125; else if exp.isExpired() &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if err != nil &#123;</span><br><span class="line">		......</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 2、该 rs 可能为新创建的，需要进行 sync</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3、若 add &lt;= 0 且 del &lt;= 0 说明本地观察到的状态已经为期望状态了</span><br><span class="line">func (e *ControlleeExpectations) Fulfilled() bool &#123;</span><br><span class="line">    return atomic.LoadInt64(&amp;e.add) &lt;= 0 &amp;&amp; atomic.LoadInt64(&amp;e.del) &lt;= 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4、判断 key 是否过期，ExpectationsTimeout 默认值为 5 * time.Minute</span><br><span class="line">func (exp *ControlleeExpectations) isExpired() bool &#123;</span><br><span class="line">    return clock.RealClock&#123;&#125;.Since(exp.timestamp) &gt; ExpectationsTimeout</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="manageReplicas"><a href="#manageReplicas" class="headerlink" title="manageReplicas"></a>manageReplicas</h5><p>manageReplicas 是最核心的方法，它会计算 replicaSet 需要创建或者删除多少个 pod 并调用 apiserver 的接口进行操作，在此阶段仅仅是调用 apiserver 的接口进行创建，并不保证 pod 成功运行，如果在某一轮，未能成功创建的所有 Pod 对象，则不再创建剩余的 pod。一个周期内最多只能创建或删除 500 个 pod，若超过上限值未创建完成的 pod 数会在下一个 syncLoop 继续进行处理。</p>
<p>该方法主要逻辑如下所示：</p>
<ul>
<li>1、计算已存在 pod 数与期望数的差异；</li>
<li>2、如果 diff &lt; 0 说明 rs 实际的 pod 数未达到期望值需要继续创建 pod，首先会将需要创建的 pod 数在 expectations 中进行记录，然后调用 slowStartBatch 创建所需要的 pod，slowStartBatch 以指数级增长的方式批量创建 pod，创建 pod 过程中若出现 timeout err 则忽略，若为其他 err 则终止创建操作并更新 expectations；</li>
<li>3、如果 diff &gt; 0 说明可能是一次缩容操作需要删除多余的 pod，如果需要删除全部的 pod 则直接进行删除，否则会通过 getPodsToDelete 方法筛选出需要删除的 pod，具体的筛选策略在下文会讲到，然后并发删除这些 pod，对于删除失败操作也会记录在 expectations 中；</li>
</ul>
<p>在 <code>slowStartBatch</code> 中会调用 <code>rsc.podControl.CreatePodsWithControllerRef</code> 方法创建 pod，若创建 pod 失败会判断是否为创建超时错误，或者可能是超时后失败，但此时认为超时并不影响后续的批量创建动作，大家知道，创建 pod 操作提交到 apiserver 后会经过认证、鉴权、以及动态访问控制三个步骤，此过程有可能会超时，即使真的创建失败了，等到 expectations 过期后在下一个 syncLoop 时会重新创建。</p>
<p><code>k8s.io/kubernetes/pkg/controller/replicaset/replica_set.go:459</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">func (rsc *ReplicaSetController) manageReplicas(......) error &#123;</span><br><span class="line">    // 1、计算已存在 pod 数与期望数的差异</span><br><span class="line">    diff := len(filteredPods) - int(*(rs.Spec.Replicas))</span><br><span class="line">    rsKey, err := controller.KeyFunc(rs)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    2、如果 &lt;0，则需要创建 pod</span><br><span class="line">    if diff &lt; 0 &#123;</span><br><span class="line">        diff *= -1</span><br><span class="line">        3、判断需要创建的 pod 数是否超过单次 sync 上限值 500</span><br><span class="line">        if diff &gt; rsc.burstReplicas &#123;</span><br><span class="line">            diff = rsc.burstReplicas</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        4、在 expectations 中进行记录，若该 key 已经存在会进行覆盖</span><br><span class="line">        rsc.expectations.ExpectCreations(rsKey, diff)</span><br><span class="line"></span><br><span class="line">        5、调用 slowStartBatch 创建所需要的 pod</span><br><span class="line">        successfulCreations, err := slowStartBatch(diff, controller.SlowStartInitialBatchSize, func() error &#123;</span><br><span class="line">            err := rsc.podControl.CreatePodsWithControllerRef(rs.Namespace, &amp;rs.Spec.Template, rs, metav1.NewControllerRef(rs, rsc.GroupVersionKind))</span><br><span class="line">            // 6、若为 timeout err 则忽略</span><br><span class="line">            if err != nil &amp;&amp; errors.IsTimeout(err) &#123;</span><br><span class="line">                return nil</span><br><span class="line">            &#125;</span><br><span class="line">            return err</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        // 7、计算未创建的 pod 数，并记录在 expectations 中</span><br><span class="line">		// 若 pod 创建成功，informer watch 到事件后会在 addPod handler 中更新 expectations</span><br><span class="line">        if skippedPods := diff - successfulCreations; skippedPods &gt; 0 &#123;</span><br><span class="line">            for i := 0; i &lt; skippedPods; i++ &#123;</span><br><span class="line">                rsc.expectations.CreationObserved(rsKey)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return err</span><br><span class="line">    &#125; else if diff &gt; 0 &#123;</span><br><span class="line">    	// 8、若 diff &gt;0 说明需要删除多创建的 pod</span><br><span class="line">        if diff &gt; rsc.burstReplicas &#123;</span><br><span class="line">            diff = rsc.burstReplicas</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		// 9、getPodsToDelete 会按照一定的策略找出需要删除的 pod 列表</span><br><span class="line">        podsToDelete := getPodsToDelete(filteredPods, diff)</span><br><span class="line"></span><br><span class="line">		// 10、在 expectations 中进行记录，若该 key 已经存在会进行覆盖</span><br><span class="line">        rsc.expectations.ExpectDeletions(rsKey, getPodKeys(podsToDelete))</span><br><span class="line"></span><br><span class="line">        // 11、进行并发删除的操作</span><br><span class="line">        errCh := make(chan error, diff)</span><br><span class="line">        var wg sync.WaitGroup</span><br><span class="line">        wg.Add(diff)</span><br><span class="line">        for _, pod := range podsToDelete &#123;</span><br><span class="line">            go func(targetPod *v1.Pod) &#123;</span><br><span class="line">                defer wg.Done()</span><br><span class="line">                if err := rsc.podControl.DeletePod(rs.Namespace, targetPod.Name, rs); err != nil &#123;</span><br><span class="line">                    podKey := controller.PodKey(targetPod)</span><br><span class="line">					// 12、某次删除操作若失败会记录在 expectations 中</span><br><span class="line">                    rsc.expectations.DeletionObserved(rsKey, podKey)</span><br><span class="line">                    errCh &lt;- err</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;(pod)</span><br><span class="line">        &#125;</span><br><span class="line">        wg.Wait()</span><br><span class="line"></span><br><span class="line">		// 13、返回其中一条 err</span><br><span class="line">        select &#123;</span><br><span class="line">        case err := &lt;-errCh:</span><br><span class="line">            if err != nil &#123;</span><br><span class="line">                return err</span><br><span class="line">            &#125;</span><br><span class="line">        default:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>slowStartBatch</code> 会批量创建出已计算出的 diff pod 数，创建的 pod 数依次为 1、2、4、8……，呈指数级增长，其方法如下所示：</p>
<p><code>k8s.io/kubernetes/pkg/controller/replicaset/replica_set.go:658</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func slowStartBatch(count int, initialBatchSize int, fn func() error) (int, error) &#123;</span><br><span class="line">    remaining := count</span><br><span class="line">    successes := 0</span><br><span class="line">    for batchSize := integer.IntMin(remaining, initialBatchSize); batchSize &gt; 0; batchSize = integer.IntMin(2*batchSize, remaining) &#123;</span><br><span class="line">        errCh := make(chan error, batchSize)</span><br><span class="line">        var wg sync.WaitGroup</span><br><span class="line">        wg.Add(batchSize)</span><br><span class="line">        for i := 0; i &lt; batchSize; i++ &#123;</span><br><span class="line">            go func() &#123;</span><br><span class="line">                defer wg.Done()</span><br><span class="line">                if err := fn(); err != nil &#123;</span><br><span class="line">                    errCh &lt;- err</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;()</span><br><span class="line">        &#125;</span><br><span class="line">        wg.Wait()</span><br><span class="line">        curSuccesses := batchSize - len(errCh)</span><br><span class="line">        successes += curSuccesses</span><br><span class="line">        if len(errCh) &gt; 0 &#123;</span><br><span class="line">            return successes, &lt;-errCh</span><br><span class="line">        &#125;</span><br><span class="line">        remaining -= batchSize</span><br><span class="line">    &#125;</span><br><span class="line">    return successes, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若 diff &gt; 0 时再删除 pod 阶段会调用<code>getPodsToDelete</code> 对 pod 进行筛选操作，此阶段会选出最劣质的 pod，下面是用到的 6 种筛选方法：</p>
<ul>
<li>1、判断是否绑定了 node：Unassigned &lt; assigned；</li>
<li>2、判断 pod phase：PodPending &lt; PodUnknown &lt; PodRunning；</li>
<li>3、判断 pod 状态：Not ready &lt; ready；</li>
<li>4、若 pod 都为 ready，则按运行时间排序，运行时间最短会被删除：empty time &lt; less time &lt; more time；</li>
<li>5、根据 pod 重启次数排序：higher restart counts &lt; lower restart counts；</li>
<li>6、按 pod 创建时间进行排序：Empty creation time pods &lt; newer pods &lt; older pods；</li>
</ul>
<p>上面的几个排序规则遵循互斥原则，从上到下进行匹配，符合条件则排序完成，代码如下所示：</p>
<p><code>k8s.io/kubernetes/pkg/controller/replicaset/replica_set.go:684</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func getPodsToDelete(filteredPods []*v1.Pod, diff int) []*v1.Pod &#123;</span><br><span class="line">    if diff &lt; len(filteredPods) &#123;</span><br><span class="line">        sort.Sort(controller.ActivePods(filteredPods))</span><br><span class="line">    &#125;</span><br><span class="line">    return filteredPods[:diff]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>k8s.io/kubernetes/pkg/controller/controller_utils.go:735</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">type ActivePods []*v1.Pod</span><br><span class="line"></span><br><span class="line">func (s ActivePods) Len() int      &#123; return len(s) &#125;</span><br><span class="line">func (s ActivePods) Swap(i, j int) &#123; s[i], s[j] = s[j], s[i] &#125;</span><br><span class="line"></span><br><span class="line">func (s ActivePods) Less(i, j int) bool &#123;</span><br><span class="line">    // 1. Unassigned &lt; assigned</span><br><span class="line">    if s[i].Spec.NodeName != s[j].Spec.NodeName &amp;&amp; (len(s[i].Spec.NodeName) == 0 || len(s[j].Spec.NodeName) == 0) &#123;</span><br><span class="line">        return len(s[i].Spec.NodeName) == 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2. PodPending &lt; PodUnknown &lt; PodRunning</span><br><span class="line">    m := map[v1.PodPhase]int&#123;v1.PodPending: 0, v1.PodUnknown: 1, v1.PodRunning: 2&#125;</span><br><span class="line">    if m[s[i].Status.Phase] != m[s[j].Status.Phase] &#123;</span><br><span class="line">        return m[s[i].Status.Phase] &lt; m[s[j].Status.Phase]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3. Not ready &lt; ready</span><br><span class="line">    if podutil.IsPodReady(s[i]) != podutil.IsPodReady(s[j]) &#123;</span><br><span class="line">        return !podutil.IsPodReady(s[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 4. Been ready for empty time &lt; less time &lt; more time</span><br><span class="line">    if podutil.IsPodReady(s[i]) &amp;&amp; podutil.IsPodReady(s[j]) &amp;&amp; !podReadyTime(s[i]).Equal(podReadyTime(s[j])) &#123;</span><br><span class="line">        return afterOrZero(podReadyTime(s[i]), podReadyTime(s[j]))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 5. Pods with containers with higher restart counts &lt; lower restart counts</span><br><span class="line">    if maxContainerRestarts(s[i]) != maxContainerRestarts(s[j]) &#123;</span><br><span class="line">        return maxContainerRestarts(s[i]) &gt; maxContainerRestarts(s[j])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 6. Empty creation time pods &lt; newer pods &lt; older pods</span><br><span class="line">    if !s[i].CreationTimestamp.Equal(&amp;s[j].CreationTimestamp) &#123;</span><br><span class="line">        return afterOrZero(&amp;s[i].CreationTimestamp, &amp;s[j].CreationTimestamp)</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="calculateStatus"><a href="#calculateStatus" class="headerlink" title="calculateStatus"></a>calculateStatus</h5><p>calculateStatus 会通过当前 pod 的状态计算出 rs 中 status 字段值，status 字段如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">status:</span><br><span class="line">  availableReplicas: 10</span><br><span class="line">  fullyLabeledReplicas: 10</span><br><span class="line">  observedGeneration: 1</span><br><span class="line">  readyReplicas: 10</span><br><span class="line">  replicas: 10</span><br></pre></td></tr></table></figure>
<p><code>k8s.io/kubernetes/pkg/controller/replicaset/replica_set_utils.go:85</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">func calculateStatus(......) apps.ReplicaSetStatus &#123;</span><br><span class="line">    newStatus := rs.Status</span><br><span class="line">    fullyLabeledReplicasCount := 0</span><br><span class="line">    readyReplicasCount := 0</span><br><span class="line">    availableReplicasCount := 0</span><br><span class="line">    templateLabel := labels.Set(rs.Spec.Template.Labels).AsSelectorPreValidated()</span><br><span class="line">    for _, pod := range filteredPods &#123;</span><br><span class="line">        if templateLabel.Matches(labels.Set(pod.Labels)) &#123;</span><br><span class="line">            fullyLabeledReplicasCount++</span><br><span class="line">        &#125;</span><br><span class="line">        if podutil.IsPodReady(pod) &#123;</span><br><span class="line">            readyReplicasCount++</span><br><span class="line">            if podutil.IsPodAvailable(pod, rs.Spec.MinReadySeconds, metav1.Now()) &#123;</span><br><span class="line">                availableReplicasCount++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    failureCond := GetCondition(rs.Status, apps.ReplicaSetReplicaFailure)</span><br><span class="line">    if manageReplicasErr != nil &amp;&amp; failureCond == nil &#123;</span><br><span class="line">        var reason string</span><br><span class="line">        if diff := len(filteredPods) - int(*(rs.Spec.Replicas)); diff &lt; 0 &#123;</span><br><span class="line">            reason = &quot;FailedCreate&quot;</span><br><span class="line">        &#125; else if diff &gt; 0 &#123;</span><br><span class="line">            reason = &quot;FailedDelete&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        cond := NewReplicaSetCondition(apps.ReplicaSetReplicaFailure, v1.ConditionTrue, reason, manageReplicasErr.Error())</span><br><span class="line">        SetCondition(&amp;newStatus, cond)</span><br><span class="line">    &#125; else if manageReplicasErr == nil &amp;&amp; failureCond != nil &#123;</span><br><span class="line">        RemoveCondition(&amp;newStatus, apps.ReplicaSetReplicaFailure)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newStatus.Replicas = int32(len(filteredPods))</span><br><span class="line">    newStatus.FullyLabeledReplicas = int32(fullyLabeledReplicasCount)</span><br><span class="line">    newStatus.ReadyReplicas = int32(readyReplicasCount)</span><br><span class="line">    newStatus.AvailableReplicas = int32(availableReplicasCount)</span><br><span class="line">    return newStatus</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="expectations-机制"><a href="#expectations-机制" class="headerlink" title="expectations 机制"></a>expectations 机制</h4><p>通过上面的分析可知，在 rs 每次入队后进行 sync 操作时，首先需要判断该 rs 是否满足 expectations 机制，那么这个 expectations 的目的是什么？其实，rs 除了有 informer 的缓存外，还有一个本地缓存就是 expectations，expectations 会记录 rs 所有对象需要 add/del 的 pod 数量，若两者都为 0 则说明该 rs 所期望创建的 pod 或者删除的 pod 数已经被满足，若不满足则说明某次在 syncLoop 中创建或者删除 pod 时有失败的操作，则需要等待 expectations 过期后再次同步该 rs。</p>
<p>通过上面对 eventHandler 的分析，再来总结一下触发 replicaSet 对象发生同步事件的条件：</p>
<ul>
<li>1、与 rs 相关的：AddRS、UpdateRS、DeleteRS；</li>
<li>2、与 pod 相关的：AddPod、UpdatePod、DeletePod；</li>
<li>3、informer 二级缓存的同步；</li>
</ul>
<p>但是所有的更新事件是否都需要执行 sync 操作？对于除 rs.Spec.Replicas 之外的更新操作其实都没必要执行 sync 操作，因为 spec 其他字段和 status 的更新都不需要创建或者删除 pod。</p>
<p>在 sync 操作真正开始之前，依据 expectations 机制进行判断，确定是否要真正地启动一次 sync，因为在 eventHandler 阶段也会更新 expectations 值，从上面的 eventHandler 中可以看到在 addPod 中会调用 rsc.expectations.CreationObserved 更新 rsKey 的  expectations，将其 add 值 -1，在 deletePod 中调用 rsc.expectations.DeletionObserved 将其 del 值 -1。所以等到 sync 时，若 controllerKey(name 或者 ns/name)满足 expectations 机制则进行 sync 操作，而 updatePod 并不会修改 expectations，所以，expectations 的设计就是当需要创建或删除 pod 才会触发对应的 sync 操作，expectations 机制的目的就是减少不必要的 sync 操作。</p>
<p>什么条件下 expectations 机制会满足？</p>
<ul>
<li>1、当 expectations 中不存在 rsKey 时，也就说首次创建 rs 时；</li>
<li>2、当 expectations 中 del 以及 add 值都为 0 时，即 rs 所需要创建或者删除的 pod 数都已满足；</li>
<li>3、当 expectations 过期时，即超过 5 分钟未进行 sync 操作；</li>
</ul>
<p>最后再看一下 expectations 中用到的几个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 创建了一个 pod 说明 expectations 中对应的 key add 期望值需要减少一个 pod， add -1</span><br><span class="line">CreationObserved(controllerKey string)</span><br><span class="line"></span><br><span class="line">// 删除了一个 pod 说明 expectations 中对应的 key del 期望值需要减少一个 pod， del - 1</span><br><span class="line">DeletionObserved(controllerKey string)</span><br><span class="line"></span><br><span class="line">// 写入 key 需要 add 的 pod 数量</span><br><span class="line">ExpectCreations(controllerKey string, adds int) error</span><br><span class="line"></span><br><span class="line">// 写入 key 需要 del 的 pod 数量</span><br><span class="line">ExpectDeletions(controllerKey string, dels int) error</span><br><span class="line"></span><br><span class="line">// 删除该 key</span><br><span class="line">DeleteExpectations(controllerKey string)</span><br></pre></td></tr></table></figure>
<p>当在 syncLoop 中发现满足条件时，会执行 <code>manageReplicas</code> 方法，在 <code>manageReplicas</code> 中无论是为 rs 创建还是删除 pod 都会调用 <code>ExpectCreations</code> 或 <code>ExpectDeletions</code> 为 rsKey 创建 expectations 对象。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要从源码层面分析了 replicaSetController 的设计与实现，但是不得不说其在设计方面考虑了很多因素，文中只提到了笔者理解了或者思考后稍有了解的一些机制，至于其他设计思想还得自行阅读代码体会。</p>
<p>下面以一个流程图总结下创建 rs 的主要流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">                                    SatisfiedExpectations</span><br><span class="line">                                    (expectations 中不存在</span><br><span class="line">                                     rsKey，rsNeedsSync</span><br><span class="line">                                     为 true)</span><br><span class="line">                                              |              判断 add/del pod</span><br><span class="line">                                              |                     |</span><br><span class="line">                                              |                     ∨</span><br><span class="line">                                              |             创建 expectations 对象,</span><br><span class="line">                                              |             并设置 add/del 值</span><br><span class="line">                                              ∨                     |</span><br><span class="line">create rs --&gt; syncReplicaSet --&gt;       manageReplicas  --&gt;          ∨</span><br><span class="line">                                       (为 rs 创建 pod)       调用 slowStartBatch 批量创建 pod/</span><br><span class="line">                                              |               删除筛选出的多余 pod</span><br><span class="line">                                              |                     |</span><br><span class="line">                                              |                     ∨</span><br><span class="line">                                              |               更新 expectations 对象</span><br><span class="line">                                              ∨</span><br><span class="line">                                    updateReplicaSetStatus</span><br><span class="line">                                    (更新 rs 的 status</span><br><span class="line">                                    subResource)</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<p><a href="https://keyla.vip/k8s/3-master/controller/replica-set/" target="_blank" rel="noopener">https://keyla.vip/k8s/3-master/controller/replica-set/</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/kube-controller-manager/" rel="tag"># kube-controller-manager</a>
          
            <a href="/tags/replicaset-controller/" rel="tag"># replicaset controller</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/28/deployment_controller/" rel="next" title="deployment controller 源码分析">
                <i class="fa fa-chevron-left"></i> deployment controller 源码分析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/11/statefulset_controller/" rel="prev" title="statefulset controller 源码分析">
                statefulset controller 源码分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 横向广告 -->
<ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-8588056830970747" data-ad-slot="8446931428" data-ad-format="auto" data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

          


          

  
    <div class="comments" id="comments">
    </div>
  

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 横向广告 -->
<ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-8588056830970747" data-ad-slot="8446931428" data-ad-format="auto" data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tianfeiyu</p>
              <p class="site-description motion-element" itemprop="description">专注 k8s 云原生实践</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          
        

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#ReplicaSetController-源码分析"><span class="nav-number">1.</span> <span class="nav-text">ReplicaSetController 源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#启动流程"><span class="nav-number">1.1.</span> <span class="nav-text">启动流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EventHandler"><span class="nav-number">1.2.</span> <span class="nav-text">EventHandler</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#addPod"><span class="nav-number">1.2.1.</span> <span class="nav-text">addPod</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#updatePod"><span class="nav-number">1.2.2.</span> <span class="nav-text">updatePod</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#deletePod"><span class="nav-number">1.2.3.</span> <span class="nav-text">deletePod</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AddRS-和-DeleteRS"><span class="nav-number">1.2.4.</span> <span class="nav-text">AddRS 和 DeleteRS</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#syncReplicaSet"><span class="nav-number">1.3.</span> <span class="nav-text">syncReplicaSet</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SatisfiedExpectations"><span class="nav-number">1.3.1.</span> <span class="nav-text">SatisfiedExpectations</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#manageReplicas"><span class="nav-number">1.3.2.</span> <span class="nav-text">manageReplicas</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#calculateStatus"><span class="nav-number">1.3.3.</span> <span class="nav-text">calculateStatus</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#expectations-机制"><span class="nav-number">1.4.</span> <span class="nav-text">expectations 机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">2.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tianfeiyu</span>

    <a href="http://www.beian.miit.gov.cn/">陕ICP备15001765号-1</a> 

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




 
    







        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <!-- <script src="//unpkg.com/valine/dist/Valine.min.js"></script> -->
  <script src="https://cdn.jsdelivr.net/npm/valine@1.3.9/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: '4rrWgTYNotH1jcsnIEprRQzE-gzGzoHsz',
        appKey: 'AwqgkQSLtSvYJzrvEJzGQrRe',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
