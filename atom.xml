<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>田飞雨</title>
  <icon>https://blog.tianfeiyu.com/icon.png</icon>
  <subtitle>专注 k8s 云原生实践</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.tianfeiyu.com/"/>
  <updated>2021-12-12T12:55:34.001Z</updated>
  <id>https://blog.tianfeiyu.com/</id>
  
  <author>
    <name>tianfeiyu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Golang GPM 模型剖析</title>
    <link href="https://blog.tianfeiyu.com/2021/12/12/golang_gpm/"/>
    <id>https://blog.tianfeiyu.com/2021/12/12/golang_gpm/</id>
    <published>2021-12-12T12:31:30.000Z</published>
    <updated>2021-12-12T12:55:34.001Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文使用 golang 1.17 代码，如有任何问题，还望指出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;线程、内核线程和用户线程区别&quot;&gt;&lt;a href=&quot;#线程、内核线程和用户线程区别&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
    
      <category term="golang runtime" scheme="https://blog.tianfeiyu.com/tags/golang-runtime/"/>
    
      <category term="GPM" scheme="https://blog.tianfeiyu.com/tags/GPM/"/>
    
  </entry>
  
  <entry>
    <title>Golang 程序启动流程分析</title>
    <link href="https://blog.tianfeiyu.com/2021/07/01/golang_bootstrap/"/>
    <id>https://blog.tianfeiyu.com/2021/07/01/golang_bootstrap/</id>
    <published>2021-07-01T12:50:30.000Z</published>
    <updated>2021-11-24T02:39:00.707Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文使用 golang 1.17 代码，如有任何问题，还望指出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Golang-代码被操作系统运行起来的流程&quot;&gt;&lt;a href=&quot;#Golang-代码被操作系统运行起来的流程&quot;
        
      
    
    </summary>
    
    
    
      <category term="golang runtime" scheme="https://blog.tianfeiyu.com/tags/golang-runtime/"/>
    
      <category term="plan9" scheme="https://blog.tianfeiyu.com/tags/plan9/"/>
    
  </entry>
  
  <entry>
    <title>golang 中函数使用值返回与指针返回的区别，底层原理分析</title>
    <link href="https://blog.tianfeiyu.com/2021/04/13/go_func_return_value_or_pointer/"/>
    <id>https://blog.tianfeiyu.com/2021/04/13/go_func_return_value_or_pointer/</id>
    <published>2021-04-13T07:36:30.000Z</published>
    <updated>2021-10-17T07:46:17.398Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#变量内存分配与回收&quot;&gt;变量内存分配与回收&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#堆与栈的区别&quot;&gt;堆与栈的区别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a
        
      
    
    </summary>
    
    
    
      <category term="golang" scheme="https://blog.tianfeiyu.com/tags/golang/"/>
    
      <category term="stack_or_heap" scheme="https://blog.tianfeiyu.com/tags/stack-or-heap/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes 中 Evicted pod 是如何产生的</title>
    <link href="https://blog.tianfeiyu.com/2021/03/01/k8s_evicted/"/>
    <id>https://blog.tianfeiyu.com/2021/03/01/k8s_evicted/</id>
    <published>2021-03-01T07:31:30.000Z</published>
    <updated>2021-10-13T07:26:05.377Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h3 id=&quot;线上被驱逐实例数据&quot;&gt;&lt;a href=&quot;#线上被驱逐实例数据&quot; class=&quot;headerlink&quot; title=&quot;线上被驱逐实例数据&quot;&gt;&lt;/a&gt;线上被驱逐实例数据&lt;/h3&gt;&lt;p&gt;最近在线上发现很多实例处于 Evicted 状态，通过 pod yaml
        
      
    
    </summary>
    
    
    
      <category term="Evicted" scheme="https://blog.tianfeiyu.com/tags/Evicted/"/>
    
  </entry>
  
  <entry>
    <title>pid cgroup</title>
    <link href="https://blog.tianfeiyu.com/2021/02/03/pid_cgroup/"/>
    <id>https://blog.tianfeiyu.com/2021/02/03/pid_cgroup/</id>
    <published>2021-02-03T12:50:30.000Z</published>
    <updated>2021-09-08T07:50:20.306Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;1、为了避免系统资源被耗光，需要对进程的最大进程数进行限制，通过向对应进程所在 cgroup 的 pid.max 文件中写入具体的数字来限制其进程数。默认值为 ‘max’ 也就是不限制，和 cgroup 最上层中的限制数保持一致。pids.current 表示
        
      
    
    </summary>
    
    
    
      <category term="cgroup v1" scheme="https://blog.tianfeiyu.com/tags/cgroup-v1/"/>
    
      <category term="pid cgroup" scheme="https://blog.tianfeiyu.com/tags/pid-cgroup/"/>
    
  </entry>
  
  <entry>
    <title>blkio cgroup</title>
    <link href="https://blog.tianfeiyu.com/2021/01/01/blkio_cgroup/"/>
    <id>https://blog.tianfeiyu.com/2021/01/01/blkio_cgroup/</id>
    <published>2021-01-01T12:50:30.000Z</published>
    <updated>2021-10-05T07:20:26.798Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h3 id=&quot;blkio-cgroup-基本功能&quot;&gt;&lt;a href=&quot;#blkio-cgroup-基本功能&quot; class=&quot;headerlink&quot; title=&quot;blkio cgroup 基本功能&quot;&gt;&lt;/a&gt;blkio cgroup 基本功能&lt;/h3&gt;&lt;p&gt;blkio 是
        
      
    
    </summary>
    
    
    
      <category term="blkio cgroup" scheme="https://blog.tianfeiyu.com/tags/blkio-cgroup/"/>
    
      <category term="cgroup v1" scheme="https://blog.tianfeiyu.com/tags/cgroup-v1/"/>
    
  </entry>
  
  <entry>
    <title>knative serving 组件分析</title>
    <link href="https://blog.tianfeiyu.com/2020/10/08/knative_serving/"/>
    <id>https://blog.tianfeiyu.com/2020/10/08/knative_serving/</id>
    <published>2020-10-08T08:19:30.000Z</published>
    <updated>2020-10-08T08:20:25.617Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;knative 部署完成后可以在 knative-serving namespace 下看到创建出的组件：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span
        
      
    
    </summary>
    
    
    
      <category term="knative" scheme="https://blog.tianfeiyu.com/tags/knative/"/>
    
      <category term="serving" scheme="https://blog.tianfeiyu.com/tags/serving/"/>
    
  </entry>
  
  <entry>
    <title>在 minikube 上部署 knative</title>
    <link href="https://blog.tianfeiyu.com/2020/09/06/deploy_with_minkube/"/>
    <id>https://blog.tianfeiyu.com/2020/09/06/deploy_with_minkube/</id>
    <published>2020-09-06T02:50:30.000Z</published>
    <updated>2020-10-08T08:22:28.663Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h3 id=&quot;安装-minkube&quot;&gt;&lt;a href=&quot;#安装-minkube&quot; class=&quot;headerlink&quot; title=&quot;安装 minkube&quot;&gt;&lt;/a&gt;安装 minkube&lt;/h3&gt;&lt;figure class=&quot;highlight
        
      
    
    </summary>
    
    
    
      <category term="knative" scheme="https://blog.tianfeiyu.com/tags/knative/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes 中的增强特性(Kubernetes Enhancement Proposal)</title>
    <link href="https://blog.tianfeiyu.com/2020/04/13/kubernetes_keps/"/>
    <id>https://blog.tianfeiyu.com/2020/04/13/kubernetes_keps/</id>
    <published>2020-04-13T12:44:30.000Z</published>
    <updated>2020-04-13T12:47:42.702Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/enhancements&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kubernetes
        
      
    
    </summary>
    
    
    
      <category term="kubernetes" scheme="https://blog.tianfeiyu.com/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>kube-apiserver 中 apiserver service 的实现</title>
    <link href="https://blog.tianfeiyu.com/2020/03/04/apiserver_bootstrap_controller/"/>
    <id>https://blog.tianfeiyu.com/2020/03/04/apiserver_bootstrap_controller/</id>
    <published>2020-03-04T06:10:30.000Z</published>
    <updated>2020-03-04T06:49:53.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;在 kubernetes，可以从集群外部和内部两种方式访问 kubernetes API，在集群外直接访问 apiserver 提供的 API，在集群内即 pod 中可以通过访问 service 为 kubernetes 的 ClusterIP。kubernetes
        
      
    
    </summary>
    
    
    
      <category term="kube-apiserver" scheme="https://blog.tianfeiyu.com/tags/kube-apiserver/"/>
    
      <category term="bootstrapController" scheme="https://blog.tianfeiyu.com/tags/bootstrapController/"/>
    
  </entry>
  
  <entry>
    <title>kube-apiserver 的设计与实现</title>
    <link href="https://blog.tianfeiyu.com/2020/02/24/kube_apiserver/"/>
    <id>https://blog.tianfeiyu.com/2020/02/24/kube_apiserver/</id>
    <published>2020-02-24T09:03:30.000Z</published>
    <updated>2020-02-24T09:36:43.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;kube-apiserver 是 kubernetes 中与 etcd 直接交互的一个组件，其控制着 kubernetes 中核心资源的变化。它主要提供了以下几个功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供 &lt;a
        
      
    
    </summary>
    
    
    
      <category term="kube-apiserver" scheme="https://blog.tianfeiyu.com/tags/kube-apiserver/"/>
    
  </entry>
  
  <entry>
    <title>kubelet 中垃圾回收机制的设计与实现</title>
    <link href="https://blog.tianfeiyu.com/2020/02/06/kubelet_garbage_collect/"/>
    <id>https://blog.tianfeiyu.com/2020/02/06/kubelet_garbage_collect/</id>
    <published>2020-02-06T08:03:00.000Z</published>
    <updated>2020-02-06T08:17:56.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;kubernetes 中的垃圾回收机制主要有两部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一是由 kube-controller-manager 中的 gc controller 自动回收 kubernetes
        
      
    
    </summary>
    
    
    
      <category term="kubelet" scheme="https://blog.tianfeiyu.com/tags/kubelet/"/>
    
      <category term="GarbageCollect" scheme="https://blog.tianfeiyu.com/tags/GarbageCollect/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes 中 Qos 的设计与实现</title>
    <link href="https://blog.tianfeiyu.com/2020/01/21/kubelet_qos/"/>
    <id>https://blog.tianfeiyu.com/2020/01/21/kubelet_qos/</id>
    <published>2020-01-21T08:28:30.000Z</published>
    <updated>2020-03-17T08:39:22.595Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h3 id=&quot;kubernetes-中的-Qos&quot;&gt;&lt;a href=&quot;#kubernetes-中的-Qos&quot; class=&quot;headerlink&quot; title=&quot;kubernetes 中的 Qos&quot;&gt;&lt;/a&gt;kubernetes 中的
        
      
    
    </summary>
    
    
    
      <category term="kubelet" scheme="https://blog.tianfeiyu.com/tags/kubelet/"/>
    
      <category term="qos" scheme="https://blog.tianfeiyu.com/tags/qos/"/>
    
      <category term="cgroup" scheme="https://blog.tianfeiyu.com/tags/cgroup/"/>
    
  </entry>
  
  <entry>
    <title>NodeController 源码分析</title>
    <link href="https://blog.tianfeiyu.com/2020/01/09/nodelifecycle_controller/"/>
    <id>https://blog.tianfeiyu.com/2020/01/09/nodelifecycle_controller/</id>
    <published>2020-01-09T12:18:30.000Z</published>
    <updated>2020-01-13T06:20:49.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;在早期的版本中 NodeController 只有一种，v1.16 版本中 NodeController 已经分为了 NodeIpamController 与 NodeLifecycleController，本文主要介绍
        
      
    
    </summary>
    
    
    
      <category term="kube-controller-manager" scheme="https://blog.tianfeiyu.com/tags/kube-controller-manager/"/>
    
      <category term="node controller" scheme="https://blog.tianfeiyu.com/tags/node-controller/"/>
    
  </entry>
  
  <entry>
    <title>kubelet 启动流程分析</title>
    <link href="https://blog.tianfeiyu.com/2020/01/03/kubelet_init/"/>
    <id>https://blog.tianfeiyu.com/2020/01/03/kubelet_init/</id>
    <published>2020-01-03T12:22:30.000Z</published>
    <updated>2020-01-03T12:34:16.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;本来这篇文章会继续讲述 kubelet 中的主要模块，但由于网友反馈能不能先从 kubelet 的启动流程开始，kubelet 的启动流程在很久之前基于 v1.12 写过一篇文章，对比了 v1.16 中的启动流程变化不大，但之前的文章写的比较简洁，本文会重新分析
        
      
    
    </summary>
    
    
    
      <category term="kubelet" scheme="https://blog.tianfeiyu.com/tags/kubelet/"/>
    
  </entry>
  
  <entry>
    <title>job controller 源码分析</title>
    <link href="https://blog.tianfeiyu.com/2019/12/31/job_controller/"/>
    <id>https://blog.tianfeiyu.com/2019/12/31/job_controller/</id>
    <published>2019-12-31T07:31:30.000Z</published>
    <updated>2020-01-03T09:37:56.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;job 在 kubernetes 中主要用来处理离线任务，job 直接管理 pod，可以创建一个或多个 pod 并会确保指定数量的 pod 运行完成。kubernetes 中有两种类型的 job，分别为 cronjob 和 batchjob，cronjob
        
      
    
    </summary>
    
    
    
      <category term="kube-controller-manager" scheme="https://blog.tianfeiyu.com/tags/kube-controller-manager/"/>
    
      <category term="job controller" scheme="https://blog.tianfeiyu.com/tags/job-controller/"/>
    
  </entry>
  
  <entry>
    <title>garbage collector controller 源码分析</title>
    <link href="https://blog.tianfeiyu.com/2019/12/28/garbagecollector_controller/"/>
    <id>https://blog.tianfeiyu.com/2019/12/28/garbagecollector_controller/</id>
    <published>2019-12-28T12:23:30.000Z</published>
    <updated>2019-12-31T05:49:55.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;在前面几篇关于 controller 源码分析的文章中多次提到了当删除一个对象时，其对应的 controller 并不会执行删除对象的操作，在 kubernetes 中对象的回收操作是由 GarbageCollectorController
        
      
    
    </summary>
    
    
    
      <category term="kube-controller-manager" scheme="https://blog.tianfeiyu.com/tags/kube-controller-manager/"/>
    
      <category term="garbage collector controller" scheme="https://blog.tianfeiyu.com/tags/garbage-collector-controller/"/>
    
  </entry>
  
  <entry>
    <title>kubelet statusManager 源码分析</title>
    <link href="https://blog.tianfeiyu.com/2019/12/25/kubelet_status_manager/"/>
    <id>https://blog.tianfeiyu.com/2019/12/25/kubelet_status_manager/</id>
    <published>2019-12-25T07:22:30.000Z</published>
    <updated>2020-01-01T08:31:07.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;本篇文章没有接上篇继续更新 kube-controller-manager，kube-controller-manager
        
      
    
    </summary>
    
    
    
      <category term="kubelet" scheme="https://blog.tianfeiyu.com/tags/kubelet/"/>
    
      <category term="statusManager" scheme="https://blog.tianfeiyu.com/tags/statusManager/"/>
    
  </entry>
  
  <entry>
    <title>daemonset controller 源码分析</title>
    <link href="https://blog.tianfeiyu.com/2019/12/18/daemonset_controller/"/>
    <id>https://blog.tianfeiyu.com/2019/12/18/daemonset_controller/</id>
    <published>2019-12-18T02:50:30.000Z</published>
    <updated>2019-12-18T03:00:40.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;在前面的文章中已经分析过 deployment、statefulset 两个重要对象了，本文会继续分析 kubernetes 中另一个重要的对象 daemonset，在 kubernetes 中 daemonset 类似于 linux 上的守护进程会运行在每一个 node
        
      
    
    </summary>
    
    
    
      <category term="kube-controller-manager" scheme="https://blog.tianfeiyu.com/tags/kube-controller-manager/"/>
    
      <category term="daemonset controller" scheme="https://blog.tianfeiyu.com/tags/daemonset-controller/"/>
    
  </entry>
  
  <entry>
    <title>statefulset controller 源码分析</title>
    <link href="https://blog.tianfeiyu.com/2019/12/11/statefulset_controller/"/>
    <id>https://blog.tianfeiyu.com/2019/12/11/statefulset_controller/</id>
    <published>2019-12-11T12:40:30.000Z</published>
    <updated>2020-01-13T02:43:20.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h3 id=&quot;Statefulset-的基本功能&quot;&gt;&lt;a href=&quot;#Statefulset-的基本功能&quot; class=&quot;headerlink&quot; title=&quot;Statefulset 的基本功能&quot;&gt;&lt;/a&gt;Statefulset
        
      
    
    </summary>
    
    
    
      <category term="kube-controller-manager" scheme="https://blog.tianfeiyu.com/tags/kube-controller-manager/"/>
    
      <category term="statefulset controller" scheme="https://blog.tianfeiyu.com/tags/statefulset-controller/"/>
    
  </entry>
  
</feed>
